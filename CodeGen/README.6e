<i> Summary

The included source files comprise a fully-function tiger compiler. In addition
to building the Codegen portion, I incorporated Wolf's ItreeGen (IG1) and
Stan's RegAlloc (RA6) into my final solution (mostly in main.sml).

My codegen implementation makes a few assumptions. First, the offsets provided
for ItreeGen in register.sml are all negative values that should be added to
the stack pointer (this means setting localsOffsetNeg to true). It also assumes
that ItreeGen is responsible for putting arguments on the stack, which means
setting Wolf's iPush value to true.

Thus, the expressions passed along with a CALL node are ignored, as the
arguments have already been evaluated and moved to the stack.

<ii> How to use

To test this implementation, I provided a test.sh and compile.sh script.
Running

 $ ./test.sh file/to/compile.tig

generates a file 'file/to/compile.tig.s', links it with the runtime.c
environment, creates the executable 'a.out', and runs it. To just generate
the assembly '.s' file, you can invoke

$ ./test.sh file/to/compile.tig

<iii> Assumptions

Aside from the assumptions mentioned in part i, I assumed that the program is
handled a valid Itree and that 80 pseudoregisters is sufficient to handle
all the computations.

<iv> Desirable features, other changed files

At this point, there are no more features required from other teams since it
works fully. In the future, I'd like to write an optimizer that removes
instructions that are redundant, such as 'movl %eax, %eax'. These show up due
to an inexhaustive munchStm, and could be remedied with some time.

I had to make a few modifications to ItreeGen's 'frame.sml' to meet the
assumptions as mentioned in part i, but all other modified files are in
the Codegen directory (excluding main.sml).



